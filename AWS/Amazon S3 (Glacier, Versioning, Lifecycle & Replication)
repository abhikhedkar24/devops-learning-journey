Today you didnâ€™t just learn S3 features; you learned real storage lifecycle behavior, which is exactly what DevOps engineers deal with in production.

Below is your ideal DevOps learnerâ€“style GitHub diary note: detailed, reflective, practical, and interview-ready â€” but still written like a real learning journey (not textbook).

You can paste this into:

03-AWS/S3/Day-XX-S3-Versioning-Lifecycle-Replication.md

ğŸ“… Day XX â€“ Deep Dive into Amazon S3 (Glacier, Versioning, Lifecycle & Replication)

Todayâ€™s session was a continuation of Amazon S3 practical learning.
The focus shifted from theory to real operational behavior of storage classes, versioning, lifecycle automation, and cross-region replication.

This session helped me understand how organizations actually manage storage cost, data recovery, and global availability in production environments.

ğŸ¯ Learning Objective

Understand Glacier storage behavior practically

Learn S3 Versioning and data recovery

Configure Lifecycle Management rules

Understand Cross Region Replication (CRR)

Observe real-world data protection strategies

ğŸ§Š Part 1 â€” Working with Glacier Storage Classes
Practical Performed

Created an S3 bucket.

Uploaded a file.

Selected Glacier storage class during upload.

Tried opening/downloading file.

Observation

Download/Open button was unavailable.

Shared link showed Access Denied.

Object was not instantly accessible.

ğŸ§  Concept Learned

Glacier storage is archival storage.

Objects stored in Glacier are not immediately accessible.

Before accessing data, we must:

ğŸ‘‰ Initiate Restore

Restore Options Learned
Bulk Retrieval (Cheapest)

Lowest cost

Slowest retrieval

Suitable for large archives

Standard Retrieval

Balanced cost and speed

Expedited Retrieval

Fastest retrieval

Most expensive

Important Realization

Glacier Deep Archive cannot be accessed instantly because it is designed for long-term storage, not active usage.

Manual movement of files regularly is impractical â€” automation is required (Lifecycle Rules).

ğŸ—‚ Part 2 â€” Understanding S3 Versioning
Initial Experiment (Versioning Disabled)

Created new bucket.

Versioning was disabled.

Uploaded same file multiple times.

Observation

New upload replaced old file.

Previous versions were lost.

Enabling Versioning

Deleted bucket.

Created new bucket with versioning enabled.

Uploaded file.

Modified file and uploaded again.

Observation

Multiple versions were stored.

Old files were preserved.

ğŸ” Key Learning

Versioning prevents accidental data loss.

Even if the latest file is deleted:

Older versions still exist.

File can be restored.

Accidental Delete Scenario

When current version was deleted:

File appeared missing.

After enabling Show Versions, older versions were visible.

Data recovery was possible.

This simulates real production recovery scenarios.

Version Types Learned

Current Version â†’ Latest file

Non-current Versions â†’ Older file copies

Delete Marker â†’ Logical deletion indicator

Permanent deletion requires deleting all versions manually.

ğŸ”„ Part 3 â€” Lifecycle Management (Automation)

Today I configured lifecycle rules to automatically manage storage cost.

Lifecycle Rule Configuration

Applied rule to all objects:

After Time	Action
30 Days	Move to Standard-IA
60 Days	Move to Glacier Flexible
90 Days	Move to Glacier Deep Archive
180 Days	Delete Object

Also configured:

Retain only 5 non-current versions.

ğŸ§  Concept Understood

Lifecycle policies automate storage optimization.

Instead of manually moving files, AWS automatically transitions objects between storage classes.

This is similar to lifecycle management used in:

EC2 snapshots

Backup retention policies

Real World Example

Application logs:

First month â†’ frequently accessed

After 2 months â†’ rarely accessed

After 3 months â†’ archive

After 6 months â†’ delete

Lifecycle rules automate this entire process.

ğŸŒ Part 4 â€” Cross Region Replication (CRR)
Objective

Reduce latency and create regional backup.

Practical Steps

Created source bucket in Mumbai region.

Created destination bucket in Ohio region.

Enabled versioning on both buckets.

Configured replication rule.

Created IAM role automatically.

Uploaded file to source bucket.

Observation

File automatically appeared in Ohio bucket.

Uploading again replicated new version.

Replication worked successfully.

Important Behavior Observed

Deleting object in source bucket did NOT delete it immediately in destination bucket.

This shows replication behavior depends on configuration rules and versioning.

ğŸ§  Concept Learned

Cross Region Replication helps with:

Disaster recovery

Low latency global access

Backup redundancy

Compliance requirements

âš ï¸ Key Technical Requirements for Replication

Versioning must be enabled on both buckets.

IAM role required for replication permissions.

Source and destination buckets must be different regions.

ğŸ” Major Takeaways from Today

Glacier storage requires restore before access.

Versioning protects against accidental deletion.

Lifecycle rules automate cost optimization.

Replication provides regional redundancy.

Storage management in AWS is mostly automation-driven.

ğŸ§  Interview-Level Understanding

If asked:

Why enable versioning?

Versioning allows recovery from accidental deletion or overwrite by maintaining historical versions of objects.

Why lifecycle management?

To automatically reduce storage costs by moving older data into cheaper storage tiers.

Why cross-region replication?

To improve availability, reduce latency, and provide disaster recovery across regions.

ğŸš€ Personal Reflection

Todayâ€™s practical helped me connect multiple S3 concepts together.

Earlier I understood storage classes individually, but now I see how:

Versioning protects data,

Lifecycle manages cost,

Replication ensures availability.

Together, these form a complete enterprise storage strategy.

âš¡ Quick Revision Points

Glacier objects require restore before access.

Versioning keeps historical copies.

Delete marker does not permanently delete data.

Lifecycle rules automate storage transitions.

Replication requires versioning enabled.

CRR improves backup and latency.

Storage optimization is automated in real systems.

This note is exactly how an ideal DevOps learner documents progress:

âœ… Practical-focused
âœ… Concept understanding
âœ… Interview-ready
âœ… Real-world thinking
âœ… Shows engineering maturity

Next improvement (very powerful):

From tomorrow, start adding at the bottom:

ğŸ§© Production Scenario

One small paragraph explaining where companies use this.

That single section will differentiate you from 90% learners.
